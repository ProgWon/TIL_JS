# 수업 내용 정리

## 서버와의 통신

HTTPS 는 아스키코드를 통한 통신이 진행됩니다. 

아스키코드는 숫자이므로 결국은 숫자로 통신하는것과 다름 없습니다.

큰 데이터를 한 번에 보내는 것이 아닌, 쪼개서 보내고 이를 패킷이라고 합니다.

만약 마지막 패킷까지 받으면 데이터를 뭉친후에 아스키코드를 문자열화 시킵니다.

메모리상에 아스키코드를 저장합니다.

브라우저는 문자열을 이해할 수 없습니다. 문자열은 표시, 즉 사람이 이해할 수 있는 언어입니다.

HTML 은 정보와 구조를 담당하고 정보를 수식하는 정보를 메타 정보라고 부릅니다.

content 라고 부르는 이유는 텍스트 뿐만 아니라 다른 HTML 요소들이 올 수 있기 때문입니다.

## index.html 에서부터 DOM 이 만들어지는 과정

루트 요청을 보내면 자연스럽게 index.html 을 서버로부터 가져오게 됩니다. 

이때 각 문자열마다 디코딩이 필요하므로 토근으로 쪼개 토근들 마다 객체로 변경시켜주는 작업이 필요합니다. 

이후 노드들의 구조를 추가시켜 DOM tree 를 만들게 됩니다.

## DOM

DOM HTML 이 파싱된 결과로서 생성된 트리 자료구조입니다.

DOM은 자료구조이므로 메서드도 가지고 있습니다.

## 왜 Tree 구조일까요?

Tree 구조는 부자관계를 표현하기에 용이한 자료구조이기 때문입니다.

또한 탐색에 있어서도 장점을 가질 수 있습니다.



렌더링 엔진은 서버로부터 응답된 HTML/CSS 를 파싱하여 DOM/CSSOM 을 생성한다. 이후 DOM/CSSOM 을 렌더링 하기 위해서 렌더 트리로 결합한다. 

클라이언트 사이드 렌더링/서버 사이드 렌더링

서버 사이드 렌더링 -> HTML 파일을 생성하는 것을 렌더링이라고 부른다.

리플로우(크롬 용어)는 요소들의 위치와 크기를 계산하는데 사용한다. 

transfiler 는 AST 를 조작해서 사용한다.

작은 회사일수록 프레임워크를 물어본다. -> 실질적으로 making 의 관점에서 물어본다.
큰 회사 -> 동작 원리, 프레임워크에 대한 질문이 적다.
실행 컨텍스트를 물어본다네요

DNS -> HTML 로드 -> DOM/CSSOM -> Render -> paint

HTML 요소 사이의 공백 문자는 텍스트 노드를 생성한다. 따라서 노드 탐색시에는 공백 문자가 생성한 공백 텍스트 노드를 주의해야 한다.

인위적으로 HTML 문서의 공백을 제거하면 공백 텍스트 노드를 생성하지 않지만 가독성이 안 좋아지기 때문에 권장하지 않는다.

요소 객체를 받는 경우 변수명에는 $ 표시를 앞에다 넣어주는 것이 좋다.

```javascript
const li = document.create('li'); // X
const $li = document.create('li'); // O
```

만약 요소 노드에 자식이 하나도 없는 경우에는 텍스트 노드를 생성해 요소 노드의 자식 노드로 텍스트 노드를 추가하는 것 보다는 textContent 프로퍼티를 사용하는 편이 더욱 간편하다.

innerHTML 은 맨 뒤에 자료 삽입이 불가능하고, 보안에 취약하다.

상태가 바뀌면 뷰가 바뀐다.

현재 상태값과 초기 상태값으로 나뉜다.

상태는 요소가 개별적으로 관리한다. -> 불행의 시작

attributes 프로퍼티는 유사 배열 객체, 이터러블인 NamedNodeMap 객체이다. 이를 통해 모든 어트리뷰트 노드의 참조가 가능하다.

초기 상태값을 가져오려면 객체.원하는상태값.value 로 가져온다.

현재 상태값은 바로 객체.value 로 가져오는것이 가능하다.

현재 상태값은 이벤트가 발생했을때 가져와야 한다. 아무때나 가져오는것이 아니다.

이벤트 핸들러는 브라우저에게 호출해달라고 요구하는 것이다. -> Event Driven Programing

앞으로 만들 함수는 이벤트 핸들러일것이다.
