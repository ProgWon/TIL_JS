# 자바스크립트란

## 1. 자바스크립트의 탄생
* 1995년 (나의 탄생 년도 ㅎ), 90%의 시장 점유율로 웹 브라우저를 지배하고 있던 **넷스케이프 커뮤니케이션즈** 는 웹페에지의 **보조적인** 기능을 수행하기 위해 경량 프로그래밍 언어를 도입한다.
* 그래서 탄생한 것이 **브렌던 아이크**가 개발한 자바스크립트이다.
* 1996년 3월, 넷스케이프 내비게이터에 탑재되었고, 모카로 명명되었다. 그러다 그 해 9월에 라이브 스크립트 -> 12월에 지금의 자바스크립트라는 이름으로 최종 명명 되었다.

## 2. 자바스크립트의 표준화
* 1996년 8월, 마이크로소프트는 자바스크립트의 파생 버전인 "JScript" 를 IE 3.0 에 탑재한다. 하지만 자바스크립트와 표준화 되지 못하는 문제가 발생한다.
* 즉, 자사 브라우저의 시장 점유율만을 높이기 위한 기능을 경쟁적으로 추가해 **크로스 브라우징 이슈** 가 발생하기 시작해, 모든 브라우저에서 동작하는 웹페이지 개발은 어려워졌다.
* 이에 자바스크립트의 파편화를 방지하고 모든 브라우저에서 정상적으로 동작하는 표준화된 자바스크립트의 필요성이 대두되었다. 이를 위해 1996년 11월에 비영리 표준화 기구인 **ECMA 인터내셔널** 에 자바스크립트의 표준화를 요청했다.
* 1997년 7월, ECMA-262라 불리는 표준화된 자바스크립트의 초판(ECMAScript1) 이 완성되고 상표권 문제로 자바스크립트는 ECMAScript 로 명명됬다. 
* 이후 1999년 ECMAScript3 (ES3), 10년 만인 2009년에 ECAMScript(ES5) 가 HTML5와 함께 출현했다.
* 2015년의 ECMAScript6(ES6) 는 let/const, 화살표 함수, 클래스, 모듈 등과 같은 범용 프로그래밍 언어로서 갖춰야 할 기능들을 대거 도입하는 큰 변화가 있었다. 이후에는 매년 비교적 작은 기능을 추가하는 수준으로 공개될것으로 예고되었다.

## 3. 자바스크립트 성장의 역사
* 초창기 자바스크립트는 웹페이지의 보조적인 기능을 수행하기 위해 한정적 용도로 사용되었다. 대부분의 로직은 주로 웹 서버에서 실행되었꼬, 서버로 전달받은 HTML 과 CSS 를 렌더링 하는 수준이었다.
### 3.1 Ajax
* 1999년 자바스크립트를 이용해 서버와 브라우저가 **비동기** 방식으로 데이터를 교환할 수 있는 통신 기능인 **Ajax** 가 XMLHttpRequest 라는 이름으로 등장했다.
* 이전의 웹은 html 태그로 시작해서 끝나는 완전한 HTML 코드를 서버로 받아 웹페이지를 렌더링하는 방식으로 동작했다. -> 화면 전환시 서버로부터 새로운 HTML 을 받아 처음부터 다시 렌더링 했다.
* 이 방식은 필요 없는 부분까지도 다시 전송받아 불필요한 부분도 다시 렌더링하는 데이터 통신이 발생해 성능에서도 불리했다. 이로 인해 화면의 순간적인 깜박임 현상이 발생해 어쩔 수 없는 한계로 받아들여졌다.
* **Ajax** 는 이전의 패러다임을 획기적으로 전환했다. 필요 없는 부분은 다시 렌더링하지 않아 필요한 데이터만 전송받아 변경하는 부분만 한정적 렌더링이 가능해졌다.
* 웹 에서도 데스크톱 애플리케이션과 같이 빠른 성능과 부드러운 화면 전환이 가능해졌다.
* 2005년 구글이 발표한 **구글 맵스**는 웹 애플리케이션 언어로 JS 의 가능성을 확인하는 계기를 마련했다. 웹 에서의 JS 와 Ajax 를 기반으로 동작하는 구글 맵스가 데스크톱 애플리케이션과 비교 했을 때에 손색이 없을 정도의 성능을 보여줬다.

### 3.2 jQuery
* 2006년, jQuery 의 등장으로 다소 번거롭고 논란이 있떤 DOM(Document Object Model)을 더욱 쉽게 제어가 가능해졌고 크로스 브라우징 이슈도 어느 정도 해결되었다.
* jQuery 는 사용자 층을 순식간에 확보했다. 배우기 까다로운 JS 보다 쉽고 직관적인 jQuery 를 선호하는 개발자가 양산되기도 했다.

### 3.3 V8 자바스크립트 엔진
* 구글 맵스를 통해 웹 앱 프로그래밍 언어로서의 가능성이 확인돼 JS 로 웹 앱을 구축하려는 시도가 늘어 더 빠르게 동작하는 JS 엔진의 필요성이 대두됬다.
* 2008년 구글의 **V8 자바스크립트 엔진**은 이러한 요구에 부합하는 빠른 성능을 보여주었다. V8 의 등장으로 데스크톱 앱과 유사한 UX(User experience)를 제공할 수 있는 언어로 정착하게 된다.
* V8 JS 엔진으로 촉발된 JS 의 발전으로 과거 웹 서버에서 수행되는 로직들이 대거 클라이언트로 이동해 이는 Front-end 영역이 주목받는 계기로 작용했다.

### 3.4 Node.js
* 2009년 라리언 달이 발표한 Node.js 는 구글 V8 JS 엔진으로 빌드된 JS 런타임 환경이다.
* Node.js 는 브라우저의 JS 엔진에서만 동작하던 JS 를 브라우저 이외의 환경에서도 동작할 수 있도록 JS 엔진을 브라우저에서 독립시킨 JS 실행 환경이다.
* 다양한 플랫폼에 적용할 수 있지만 서버 사이드 앱에 주로 사용되며 모듈, 파일 시스템, HTTP 등 built-in API 를 제공한다.
* Node.js 는 JS 엔진을 기반으로 하므로, Node.js 환경에서 동작하는 앱은 JS를 사용해 개발한다. 프론트와 백엔드 영역에서 자바스크립트를 사용할 수 있다는 동형성은 별도의 언어 학습 시간을 덜 수 있다는 장점이 있다.   
* Node.js 는 **비동기 I/O** 를 지원하며 **단일 스레드 이벤트 루프** 기반으로 동작해 요청 처리 성능이 좋다. Node.js 는 데이터를 실시간 처리하기 위해 I/O 가 많이 발생하는 SPA 에 적합핟.
* 하지만, CPU 사용률이 높다면 권장하지 않는다.
* Node.js 등장으로 JS 는 브라우저를 벗어나 서버 사이드 앱 개발에서도 사용 가능한 범용 프로그래밍 언어가 되었다. 브라우저에서만 동작하던 반쪽짜리 언어가 아닌 프론트, 백엔드 까지 아우르는 웹 프로그래밍 언어의 표준으로 자리 잡게 되었다.
* 이제 JS 는 **크로스 플랫폼** 을 위한 가장 중요한 언어로 주목 받는다. 웹 뿐만 아닌 모바일 하이브리드 앱, 서버 사이드, 데스크톱, 머신러닝, 로보틱스 환경을 위한 언어로 가장 인기있는 언어이다.

### 3.5 SPA 프레임워크
* 모던 웹 앱은 데스크톱 앱과 비교해도 손색없을 정도의 성능과 사용자 경험을 제공하는것이 필수가 되었다. 더불어 개발 규모의 복잡도도 증가했다.
* 이전의 개발 방식은 복잡해진 개발 방식을 수행하기 어려웠고 이러한 필요에 따라 많은 패턴과 라이브러리가 출현했다. 그 덕에 개발에 많은 도움을 주었지만 변경에 유연하면서 확장하기 쉬운 앱 아키텍처의 구축을 어렵게 했고 필연적으로 프레임워크가 등장한다.
* 이러한 요구에 발맞춰 CBD(Component Based Development) 방법론을 기반으로 하는 SPA 가 대중화되면서 Angular, React, Vue.js, Svelte 등 다양한 프레임워크/라이브러리 또한 많은 사용층을 확보하고 있다.

### 4. 자바스크립트와 ECMAScript
* ECMAScript 는 JS 표준 사양인 ECMA-262 를 말한다. 프로그래밍 언어의 값, 타입, 객체와 프로퍼티, 함수, 표준 빌트인 객체 등의 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 JS 엔진을 구현한다.
* JS 는 일반적으로 프로그래밍 언어로서 core 를 이루는 ECMAScript 와 브라우저가 별도 지원하는 **클라이언트 사이드 Web API**, 즉 DOM, BOM, Canvas, XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker 등을 아우르는 개념이다.
* 클라이언트 사이드 Web API 는 ECMAScript 와는 별도로 **W3C** 에서 별도의 사양으로 관리하고 있다.

### 5.자바스크립트의 특징
* JS 는 HTML, CSS 와 함께 웹을 구성하는 요소 중 하나로 **웹 에서 동작하는 유일한 프로그래밍 언이**이다. 다른 언어와 마찬가지로 기존의 프로그래밍 언어에서 많은 영향을 받았다. 기본 문법은 C, java 와 유사하고 self 에서는 프로토타입 기반 상속, scheme 에서는 일급 함수의 개념을 차용했다.
* JS 는 개발자가 별도의 컴파일 작업을 수행하지 않는 **인터프리터 언이** 이다. 대부분의 모던 JS 엔진(V8, SpiderMonkey, JavaScriptCore, Chakra)은 인터프리터 언어와 컴파일러의 장점을 결합해 비교적 처리 속도가 느리는 인터프리터 단점을 해결했다.
* 인터프리터는 소스코드를 즉시 실행하고 컴파일러는 빠르게 동작하는 머신 코드를 생성하고 최적화한다. 이를 통해 컴파일 단계에서 추가적 시간 필요없이 빠르게 코드 실행이 가능하다.
* 대부분의 모던 브라우저에서 사용되는 인터프리터는 전통적인 **컴파일러 언어** 처럼 명시적 컴파일 단계를 거치지 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행한다.
* 이를 통해 인터프리터 언어의 장점인 동적 기능 지원을 살리며 실행 속도가 느리다는 단점을 극복한다. 따라서 현재는 컴파일러와 인터프리터의 기술적 구분이 점차 모호해져 간다. 
* 하지만 JS 는 런타임에 컴파일되어 실행 파일 생성 없이 인터프리터 도움이 없으면 실행할 수 없기 때문에 컴파일러 언어라고는 할 수 없다.
* JS 는 **명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍** 을 지원하는 **멀티 패러다임 프로그래밍 언어** 이다.
* 비록 다른 객체지향 언어와의 차이점에 대한 논쟁들이 있지만, JS 는 강력한 객체지향 프로그래밍 능력을 지니고 있다. 간혹 클래스, 상속, 정보 은닉을 위한 키워드 private 가 없어 객체지향 언어가 아니라고 하는 경우가 있지만, JS 는 클래스 기반 객체지향 언어보다 효율적이고 강력한 프로토타입 기반의 객체지향 언어이다.

### 6. ES6 브라우저 지원 현황
* IE 를 제외한 대부분의 모던 브라우저는 ES6 를 지원하고 있지만 100% 지원하고 있지는 않다. IE 를 제외한 ES6 지원 비율은 거의 96~99%로 거의 100%에 육박하지만 IE나 구형 브라우저는 ES6를 대부분 지원하지 않는다.
* 따라서 브라우저에서 아직 지원하지 않는 최신 기능을 사용하거나, IE, 구형 브라우저를 고려해야 한다면 **Babel** 과 같은 트랜스 파일러를 사용해 ES6 코드를 ES5 로 다운그레이드 할 필요가 있다.



