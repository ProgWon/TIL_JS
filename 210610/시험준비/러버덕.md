# 러버덕 

## 소스코드의 타입
1. 전역
2. 함수
3. eval
4. 모듈

## 전역코드의 범위

함수의 범위는 포함하지 않는다.

## 프로토타입으로 상속을 구현하는 이유

생성자 함수로만 구현하면 함수를 만들때마다 메서드

## 이터러블이란

이터레이터 객체를 반환하는 

## 이터레이션 프로토콜
이터러블 프로토콜과 이터레이터 프로토콜을 만족해야 함.

## 지연평가
데이터가 필요한 시점에 비로소 데이터를 생성하는 평가

## __proto__ 로 접근을 하는 이유
순환참조가 발생할 수 있기 때문

## 캡슐화
상태를 나타내는 프로퍼티와 메서드를 하나로 뭉쳐놓은것

## 실행컨텍스트
코드의 흐름과 식별자들을 저장하는 렉시컬환경을 관리하는 곳

## 정적, 프로토타입, 인스턴스
정적 메서드는 인스턴스를 만들지 않아도 호출이 가능하다. 프로토타입 메서드는 인스턴스들이 상속받아서 사용하는 것을 목적으로 하고 인스턴스 메서드는 인스턴스만이 가져야 할 메서드를 따로 정의해서 사용한다.

## 클래스와 생성자 함수의 차이
new 연산자 없이 호출하면 에러 발생
extend 와 super 가 존재
암묵적으로 strict mode 구현
enumerable false
호이스팅

## constructor vs prototye.constructor
클래스는 인스턴스 생성하고 초기화하기 위한 특수 메서드이고 프로토타입의 경우 생성자 함수로 사용할 수 있다는 것을 나타내는 프로퍼티이다.

## ES6 이전의 함수의 단점
모두가 constructor 를 가지고 있다는 점이 문제가 된다. 필요하지 않은 객체를 만든다.

## 화살표 함수와 일반 함수의 차이
this 바인딩이 존재하지 않아 상위 스코프의 this 를 참조한다.

## super
1. 호출하면 상속받은 부모 클래스의 constructor 를 호출한다.
2. 참조하면 수퍼클래스의 메서드를 호출 가능하다.

## 래퍼 객체
string, number, boolean, symbol 과 같은 원시값을 객체처럼 접근했을 때 임시로 만들어지는 객체.

## strict mode
JS 의 문법을 좀 더 엄격히 적용해 명시적인 에러를 발생시켜준다.

## 객체를 생성하는 5가지 방법
Object.create, 객체 리터럴, 생성자 함수, 클래스, Object 생성자 함수

## 캡처링과 버블링
캡처링은 상위 요소에서 하위 자식 요소로 이벤트가 전달된다. 버블링은 이벤트가 일어난 하위 요소가 상위요소로 이벤트가 전달된다.

## 이벤트 위임하는 이유
상위 DOM 요소에 이벤트를 주었을 때 모든 하위 요소에게 이벤트를 줄 필요가 없다.

## 이벤트 핸들러를 만드는 3가지 방식
1. 어트리뷰트 방식: on 접두사와 이벤트타입을 통해서 HTML 어트리뷰트에 선언하는 방식 값으로 문을 할당해야 한다.
2. 프로퍼티 방식: 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩하는 방법으로 1개만 가능하다.
3. addEventListener: 첫 매개변수에 이벤트 종류를 전달하는데 이때 On 접두사를 붙이지 않는다. 두번째 매개변수에는 이벤트 핸들러를 전달하고 마지막 매개 변수에 캡처링과 버블링 지정이 가능하다.

## DOMContentLoaded 방식을 등록
addEventListner 만 사용해서 등록이 가능하다.

## this 란 무엇인가
자신이 속한 객체나 인스터스를 가리키는 자기 참조 변수이다.


## this 를 교체하는 방법
call, bind, apply

## callback this 문제
콜백 함수는 중첩 함수 내부에서 일반 함수로 호출되게 된다. 이때 this 는 일반 함수로 호출되기 때문에 window 를 가리키게 된다. 따라서 화살표 함수를 통해 내부 this 문제를 해결해 줘야 한다.

## 추상화
객체지향 프로그래밍 내에서 원하는 속성을 추려내는 과정

## 클로저를 사용하는 이유
의도치 않게 상태를 변경되지 않도록 안전하게 은닉하고 특정한 함수에게만 상태를 변경하는 것을 허용하기 위해 사용. 상태를 안전하게 변경하고 유지하기 위해서 사용한다.

## forEach forOf
forEach 를 break, continue 를 사용하는 것이 불가능하다. 즉 모든 반복문을 순회하는 것을 가정하고 만들어지는 것

## map vs 일반 객체
일반 객체는 key 값으로 symbol, string 밖에 사용할 수 없지만 일반 객체는 key 로 객체를 포함한 모든 값을 사용 가능하다. 

## Symbol 이란?

## 브라우저의 렌더링 과정

## this DOM 요소

## 토큰
문법적의미가 

## 배열의 메서드를 활용해서 remove 를 구현하면?
-1인지 확인 indexof, splice 를 이용해서 삭제를 구현합니다.  

## 배열은 배열이 아닌이유

## 희소 배열

## 정렬
문자열로 비교를 하기 때문에

## target, currentTarget