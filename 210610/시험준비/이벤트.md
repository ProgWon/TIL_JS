# 이벤트

## 이벤트 핸들러란? 
이벤트가 발생했을 때 호출되는 함수를 이벤트 핸들러라고 하고 이벤트가 발생했을 때 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라고 한다.

## 왜 이벤트 핸들러의 호출을 브라우저에게 위임할까?
만약 사용자가 버튼을 클릭했을 때 함수를 호출해 처리를 하고 싶은 경우에 문제는, 언제 함수를 호출해야 하는가이다. 사용자가 언제 버튼을 클릭할지 알 수 없으므로 언제 함수를 호출 해야 할 지를 알 수 없다.

하지만 브라우저는 사용자의 버튼 클릭을 감지해 클릭 이벤트를 발생시니는 것이 가능하다. 즉, 개발자는 함수를 언제 호출할지 모르지만 브라우저는 알기 때문에 브라우저에게 함수 호출을 위임하는 것이다.

## 이벤트 드리븐 프로그래밍
프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍이라고 한다.

## 이벤트 핸들러 등록 방식
이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라고 한다.

### 1. 어트리뷰트 방식
on 접두사 + 이벤트 타입 으로 이루어진 이벤트 핸들러 어트리뷰트 이름에 함수 호출문 등의 문을 할당하는 방식. 함수 참조가 아닌 함수 호출문등의 문을 할당해야 한다. 즉 값으로 어트리뷰트에 등록되지만 이때 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미한다. 여러 개의 문을 할당하는 것이 가능하다.

### 2. 이벤트 핸들러 프로퍼티 방식
DOM 노드 객체는 이벤트 핸들러 프로퍼티를 가지고 있다. on 접두사 + 이벤트 타입으로 이루어진 프로퍼티 키를 통해서 함수를 바인딩하는 방식이다. 하나의 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있음.

### 3. addEventListner 방식
DOM Level2 에서 도입된 EventTarget.prototye.addEventListner 메서드를 사용하는 방식. 첫번째 매개변수에 이벤트 타입, 두번째 매개변수에 이벤트 핸들러를 전달하는 방식. 마지막 매개변수를 통해 캡처링 버블링의 지정이 가능하다. 이벤트 핸들러 프로퍼티 방식과 다르게 여러개의 이벤트 핸들러가 모두 호출된다. 즉, 하나 이상의 핸들러 등록이 가능하다.

## addEventListner 메서드로 등록한 이벤트 핸들러 제거
removeEventListner 를 사용한다. 전달할 인수는 동일하나 일치하지 않으면 핸들러가 제거되지 않는다. 만약 무명 함수를 이벤트 핸들러로 등록하면 제거가 불가능. 제거하려면 참조를 변수나 자료구조에 저장해야함.

단, 이벤트 핸들러 내부에서 removeEventListner 메서드를 호출한 경우에는 제거가 가능함.

arguments.callee 를 사용해서 제거도 가능하지만 코드 최적화를 방해함. 안 쓰는게 좋음 

만약 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러는 removeEventListner 로 제거하는게 불가능함. 제거하려면 프로퍼티에 null 을 할당해야함.

## 이벤트 객체
이벤트가 발생하면 이벤트 객체가 동적으로 생성됨. 이는 이벤트 핸들러의 첫 번째 인수로 전달됨. 이벤트 객체를 전달받으려면 이벤트 핸들러 정의할 때 전달받을 매개변수를 명시적으로 선언해야함.

이벤트 핸들러 어트리뷰트 방식은 이벤트 핸들러의 첫 번째 매개변수 이름이 반드시 event 여야 함. event 가 아닌 다른 이름으로 매개변수 선언하면 이벤트 객체 전달 받지 못함. 

이벤트 핸들러 어트리뷰트 방식에서 이벤트 핸들러 어트리뷰트 값은 사실 암묵적으로 생성되는 이벤트 핸들러의 함수 몸체를 의미하기 때문임.

## 이벤트 전파
DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해서 전파됨. 이벤트 객체는 event target 을 중심으로 DOM 트리를 통해서 전파됨

이벤트 객체는 window 에서 시작해서 이벤트 타깃 방향으로 전파됨 -> 캡처링 단계. 
이후에 이벤트 타깃에 도달함. -> 타깃 단계
이후 이벤트 타깃부터 시작해서 winodw 방향으로 전파됨 -> 버블링 단계

이벤트 핸들러 어트리뷰트, 이벤트 핸들러 프로퍼티 방식은 타깃, 버블링 단계만 캐치 가능
addEventListner 는 캡처링도 선별적 캐치가 가능함 -> 3번째 인수 true 주면 됨.

## 이벤트 위임
만약 ul 하나에 li 100 개 있다고 가정할때 li 클릭시 이벤트를 발생하고 싶으면 li 100개에 전부 이벤트를 걸어줘야 함. -> 굉장히 불편하고 성능 저하의 원인 유지보수 부적합해짐.

그렇다면 ul 에다가 이벤트를 위임하는 것임. 상위 DOM 요소에 이벤트 핸들러를 등록하는 것임. 이벤트 타깃이 li 인것을 상위 요소에서 캡처가 가능하기 때문에 상위 DOM 요소에 이벤트 타깃을 전달해서 이벤트를 실행시켜주면 되는 것임.

만약 다른 자식들이 있다면 예외처리 가능. 이때는 matches 메서드를 통해서 확인하면 됨.

currentTarget 프로퍼티는 현재 순회중인? 이동중인? DOM 요소를 가리키고 target 프로퍼티는 이벤트가 발생한 DOM 요소를 가리킴. 즉 target 프로퍼티는 실제로 이벤트를 발생시킨 DOM 요소를 가리킴

## preventDefault

DOM 요소는 저마다 기본 동작이 있음. preventDefault 는 이런 DOM 요소의 기본 동작을 중단시킴

## stopPropagation
하위 DOM 요소의 이벤트를 개별적 처리 가능하도록 이벤트 전파를 막아줌.

## 이벤트 핸들러 내부의 this
이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 사실 암묵적으로 생성되는 이벤트 핸들러의 문임. 즉, 일반 함수로 호출되기 때문에 this 는 전역 객체를 가리킴

단, 이벤트 핸들러를 호출할 때의 인수로 전달한 this 는 바인딩한 DOM 요소를 가리킴

### 이벤트 핸들러 프로퍼티 vs addEventListner
둘다 내부의 this 는 이벤트를 바인딩한 DOM 요소를 가리킴. -> 이벤트 객체의 currentTarget 과 같음

## 이벤트 핸들러에 인수 전달
이벤트 핸들러 어트리뷰트 방식은 함수 호출문을 사용할 수 있어 인수 전달이 가능하다. 하지만 이벤트 핸들러 프로퍼티 방식과 addEventListner 메서드 방식은 이벤트 핸들러를 브라우저가 호출하기 때문에 함수 자체를 등록해야 한다. 즉, 인수 전달이 불가능하다.

## 커스텀 이벤트
개발자의 의도로 생성된 이벤트를 커스텀 이벤트라고 부른다. 커스텀 이벤트 객체는 버블링 되지 않으며 preventDefault 메서드로 취소도 불가능하다.

만약 임의의 이벤트 타입을 지정해 커스텀 이벤트 객체를 생성하면 반드시 addEventListner 메서드 방식으로 등록해야 한다. 그 이유는 on + 이벤트 타입으로 이루어진 요소 노드가 존재하지 않기 때문이다.

## 디스패치
커스텀 이벤트는 디스패치가 가능하다. dispatchEvent 메서드에 이벤트 객체를 인수로 전달해서 호출하면 이벤트가 발생한다.

dispatchEvent 는 동기 처리 방식으로 호출한다. 



## 이벤트 타깃
이벤트를 발생시킬 객체

## 이벤트 타입
이벤트의 종류를 나타내는 문자열

## 이벤트 핸들러
이벤트가 발생되면 호출할 함수
