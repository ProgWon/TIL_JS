# __proto__

## 시작

모든 객체는 __proto__ (프로토 접근자 프로퍼티) 를 통해서 자신의 프로토타입에 접근할 수 있습니다. 정확히 얘기하면 [[Prototype]] 이라는 내부 슬롯에 간접적으로 접근이 가능합니다.

## 본론

1. __proto__ 는 접근자 프로퍼티이다.

내부 슬롯과 내부 메서드는 프로퍼티가 아닙니다. 그렇기 때문에 원칙적으로 직접적인 접근과 호출 할 수 있는 방법을 제공하지 않습니다. 단 일부 내부 슬롯과 내부 메서드의 경우 간접적인 접근 수단을 제공합니다. 프로토타입 내부 슬롯의 경우 프로토 접근자를 통해 간접적으로 접근이 가능합니다.

또한 접근자 프로퍼티 이기때문에 값을 가지지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로서 동작합니다.

2. __proto__ 는 상속을 통해 사용된다.

proto 는 상속을 통해서 사용됩니다. 즉, proto 접근자 프로퍼티는 객체가 직접 소유하지 않고 Object.prototype 의 프로퍼티 입니다. 모든 객체들은 상속을 통해 proto 접근자 프로퍼티를 사용 가능합니다.

3. __proto__ 를 사용해서 프로토타입에 접근하는 이유는?

그렇다면 이 __proto__ 를 사용해서 프로토타입에 접근하는 이유는 무엇일까요? 예제를 통해 살펴보겠습니다.

(그림을 그린다)

만약 서로가 상호 참조에 의해 프로토타입 체인이 생성된다면 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인이 만들어집니다. 여기서 __proto__ 는 에러를 발생시킵니다.

프로토타입 체인은 단방향 링크드 리스트로 구현되어야 합니다. 즉 검색 방향은 한 방향으로만 흘러가야합니다. 만약 그렇지 않을 경우에는 서로가 서로를 계속해서 참조하는 비순환적인 구조가 발생해 무한 루프에 빠질 수 있습니다.

아무런 체크 없이 무조건적으로 교체할 수 없도록 __proto__ 접근자를 통해 프로토타입에 접근하고 교체하도록 구현되어 있습니다.

4. __proto__ 를 코드 내에서 사용하는 것은 권장하지 않는다.

ES5 까지 __proto__ 는 ECMAScript 에 포함되지 않은 비표준이었습니다. 하지만 일부 브라우저에서 지원하고 있어 호환성을 고려해 ES6 에서 __proto__ 를 표준으로 채택했습니다.

하지만 이를 코드 내에서 사용하는것은 권장하지 않습니다. 저희는 모든 객체는 Object.prototype 의 상속을 받는다고 얘기 했지만 사실 이를 상속받지 않은 객체가 있을 수도 있어 __proto__ 를 사용해도 undefined 를 얻을 수 있기 때문입니다.

따라서 Object.getPrototypeOf 메서드를 사용하거나 프로토타입 교체시에는 Obejct.setPrototypeOf 를 사용하는 것을 권장합니다.

