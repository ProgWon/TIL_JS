심볼은 유일무이한 값이다. 즉, 애플리케이션 내에서 유일무이 하다는 것이다. 심볼 값은 심볼 컨테이너 안에서 관리된다.

Symbol.for 뒤에 키값을 주면 전역 심벌 레지스트리에 존재하면 반환, 없으면 새로 만든다.
프로퍼티키는 문자열과 심볼값으로 만드는것이 가능하다. 식별자와 프로퍼티키는 완전하게 다른 개념이다. 식별자는 식별자, 프로퍼티는 식별자가 아닌 키일뿐이다. 따라서 프로퍼티와 식별자는 저장하는 공간이 다르다.

식별자는 스코프 체인에서 관리되고 프로퍼티는 프로토타입 체인에서 관리된다. 식별자는 중복이 불가능하다.(let, const 사용시) -> 에러가 발생하니 인지가 가능하다. 프로퍼티는 중복이 허용되어 덮어씌우기가 되버린다. 이는 인지하는 것이 불가능하다는 것이다.

Symbol 값의 컨셉은 프로퍼티키를 만들기 위해서, 즉 중복되지 않는 프로퍼티 키를 생성하는 방법이다.

왜 프로퍼티키를 중복시키지 않으려고 했을까??

JS 의 사양에서 앞으로 새로운 메서드가 들어올수도 있다. 이때 기존의 안티패턴이라고 하는 프로토타입 메서드를 직접 추가하는 경우도 발생한다. 이 경우에는 덮어 쓸 가능성이 존재한다. 만약 추가되었지만 메서드의 이름이 심볼이면 절대적으로 중복이 불가능하다.

심볼은 객체로서 생성자 함수로 쓰일때가 있어서 심볼도 prototype 을 가지고 있다. 이는 문자열이라는 원시값이 존재하고 String 이라는 객체가 있는것과 똑같다.

new 를 사용해서 생성자 함수를 호출하지 불가능한 이유는 심볼 자체에서 문법적으로 막아놓았기 때문이다. 하지만 래퍼 객체를 만든다는것은 똑같다.

이터러블은 순회할 수 있는 자료구조이다. 이터레이션 프로토콜이 존재한다. 

이터레이션 프로토콜에는 이터러블 프로토콜과 이터레이터 프로토콜이라는 것이 존재한다. 

이터러블 프로토콜은 Symbol.iterator 라는 메서드를 호출해 이터레이터를 반환해야 한다.

이터레이터 프로토콜은 Symbol.iterator 를 호출하면 이터레이터 리절트 객체를 반환해야 한다. value, done 이라는 프로퍼티가 있다. 이터러블이라는 자료구조가 새로 생겼다고 생각하면 좋다.

Symbol.iterator 를 키로 가지는 메서드가 있으면 이터러블이다. 이터러블이면서 유사배열인것이 있을 수 있다. -> arguments, string

스프레드 문법의 대상은 이터러블이다. 이터러블은 스프레드 문법과 for...of 의 대상이 될 수 있다. 

스프레드는 연산자가 아니다 -> 값을 만들지 않는다. operator 의 정의는 값을 만들어내는 것이지만 문법의 결과는 값이 아니다.

객체 디스터럭처링은 할당 기준이 프로퍼티 키이다. 선언한 변수가 프로퍼티 키 이름과 일치하면 할당되는 것이다.

만약 객체가 중첩되어 있다면 프로퍼티 키로 객체를 추출하고 객체의 키로 다시 프로퍼티 키를 추출한다.

배열 디스터럭처링과 객체 디스트럭처링은 한번에 사용이 가능하다. 

호스트 객체는 WEB API 라고 불린다. 즉, node.js 환경에서 실행하면 안된다.