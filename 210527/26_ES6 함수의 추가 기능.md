# 25. ES6 함수의 추가 기능

## 1. 함수의 구분

ES6 이전 JS 함수는 별다른 구분 없이 다양한 목적으로 사용되었다. 일반적 함수의 호출, new 연산자를 이용한 생성자 함수로의 호출도 가능하고 객체에 바인딩 되어 메서드로도 가능하다. 언뜻 보면 이는 굉장히 유연해보이지만 사실 많은 실수를 유발한 가능성이 있으며 성능에서도 손해이다. ES6 이전의 함수는 일반 함수로서 호출, 생성자 함수로도 전부 호출이 가능하다. -> callable 이면서 constructor 이다.

주의해야 할 내용은 일반적으로 메서드라고 부르던 객체에 바인딩된 함수도 ES6 이전에는 callable 이며 constructor 라는 것이다. 이렇게 메서드를 생성자 함수로 호출하는 것은 흔치 않지만 문법상으로 가능하다는 점은 문제가 된다. 성능 면에서도 객체에 바인딩된 함수가 prototype 프로퍼티와 프로토타입 객체를 생성한다는 것은 문제가 된다. 

이러한 문제를 극복하기 위해 ES6 는 함수를 사용 목적에 따라 세 가지로 구분한다. 

1. 일반 함수 : 함수 선언문이나 함수 표현식으로 정의된 함수로 ES6 이전과 차이가 없다.
2. 메서드 와 화살표 함수 : ES6 이전과의 함수와 명확한 차이를 가진다.

## 2. 메서드

ES6 이전 사양의 경우 메서드에 대한 명확한 정의가 없었다. 메서드는 객체에 바인딩된 함수를 일컫는 의미로 사용됬다. ES6 사양에서 메서드는 **메서드 축약 표현으로 정의된 함수**만을 의미한다. ES6 의 매서드는 인스턴스 생성이 불가능한 **non-constructor** 이다. -> 생성자 함수로서 호출이 불가능하다. -> 인스턴스를 생성할 수 없다 -> prototype 프로퍼티가 없고 프로토타입을 생성하지도 않는다. (표준 빌트인 객체가 제공하는 프로토타입 메서드와 정적 메서드는 모두 non-constructor 이다.)

ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]] 를 가진다. super 참조 함수는 내부 슬롯 [[HomeObject]] 를 사용하여 수퍼클래스의 메서드를 참조하므로 내부 슬롯 [[HomeObject]] 를 갖는 ES6 메서드는 super 키워드의 사용이 가능하다.

## 3. 화살표 함수

화살표 함수는 function 키워드 대신 화살표를 사용하여 기존의 함수 정의 방식보다 간략하게 함수 정의가 가능하다. 이는 표현만 간략한 것이 아닌 내부 동작도 기존 함수보다 간략하다. 특히 화살표 함수는 콜백 함수 내부의 this 가 전역 객체를 가리키는 문제를 해결하는 대안으로 유용하다.

### 3.1 화살표 함수 정의

#### 1. 함수 정의

화살표 함수는 함수 선언문이 아닌 함수 표현식으로 정의해야 한다.

```javascript
const multiply = (x, y) => x * y;
multiply(2, 3);
```

#### 2. 매개변수 선언

매개변수가 여러 개인 경우 소괄호 () 안에 매개변수를 선언한다.

```javascript
const arrow = (x, y) => { ... };
```

매개 변수가 한 개인 경우 소괄호의 생략이 가능하다.

```javascript
const arrow = x => { ... };
```

매개 변수가 없는 경우에는 생략이 가능하다.

```javascript
const arrow = () => { ... };
```

#### 3. 함수 몸체 정의

함수 몸체가 하나의 문으로 구성된다면 중괄호의 생략이 가능하다. 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적 반환된다. 만약 중괄호를 생략했을 때, 함수 몸체 내부의 문이 표현식이 아닌 문이라면 에러가 발생한다. 표현식이 아닌 문은 반환이 불가능하다.

객체 리터럴의 경우 소괄호로 감싸주어야 한다. 그렇지 않으면 객체 리터럴의 중괄호를 함수 몸체를 감싸는 중괄호로 잘못 해석한다. (문맥이 중요하다.)

화살표 함수도 즉시 실행 함수로 사용이 가능하다. 일급 객체이기 때문에 고차 함수에 인수로 전달할 수 있는데, 이 경우에 일반적이 함수 표현식보다 표현이 간결하고 가독성이 좋아진다.

### 3.2 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 non-constructor 이다.
2. 중복된 매개변수 이름의 선언이 불가능하다.
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 가지고 있지 않다.

### 3.3 this

일반 함수와의 가장 큰 차이점은 this 이다. 화살표 함수는 콜백 함수로 많이 사용된다. 화살표 함수의 this 는 콜백 함수 내부의 this 문제를 해결하기 위해 **의도적으로 설계** 되었다. this 바인딩은 함수의 호출 방식에 따라 동적으로 결정된다. 함수 정의가 아니라 함수 호출시에 this 바인딩할 객체가 동적으로 결정된다.

콜백 함수를 일반 함수로 호출하는 경우 this 는 전역 객체를 가리킨다. strict mode 에서 일반 함수로서 호출된 모든 함수 내부의 this 에는 전역이 아닌 **undefined** 가 바인딩 되는데, 이 때 발생하는 문제가 콜백 함수 내부의 this 문제이다.

화살표 함수는 **함수 자체의 this 바인딩을 가지지 않는다.** 따라서 화살표 함수 내부에서 this 를 참조하면 상위 스코프의 this 를 그대로 참조하는데 이를 lexical this 라고 한다.

화살표 함수는 함수 자체의 this 바인딩을 가지지 않는다. 이를 통해 Function.prototype.call, Function.prototype.apply, Function.prototype.bind 메서드를 사용해도 화살표 함수 내부의 this 교체가 불가능하다. (러버덕때 궁금했던 내용이었는데 팀끼리 했던 가정이 맞았다!) 호출은 가능하나 교체할 수 없다는 의미이다.

화살표 함수로 메서드를 정의하지 말자. 항상 상위 스코프를 this 로 가리키기 때문에 호출한 객체를 가리키지 못한다.



