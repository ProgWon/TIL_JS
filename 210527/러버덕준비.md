# 러버덕 준비

## this 바인딩이란?

바인딩은 식별자와 값을 연결하는 과정을 이야기합니다. this 바인딩은 즉, this 가 가리킬 객체를 바인딩하는 것을 의미합니다.

자바나 C++ 같은 경우에 this 는 언제나 클래스가 생성할 인스턴스를 가리킵니다. 하지만 자바스크립트의 this 는 함수가 호출되는 방식에 따라 this 바인딩이 동적으로 일어납니다.

JS 에서는 this 바인딩이 결정되는 경우가 크게 3가지가 있습니다.

## 일반 함수 호출

첫 번째로는 일반 함수 호출입니다.

일반 함수로 호출하면 함수 내부의 this 는 전역 객체가 바인딩됩니다. 중첩 함수나 콜백 함수를 포함한 모든 함수들이 일반 함수로 호출된다면 내부의 this 에는 전역 객체가 바인딩되게 됩니다. 

이 경우에는 외부 함수에 대한 헬퍼 함수의 동작을 어렵게 만듭니다. 이를 해결하기 위해서는 따로 변수를 만들어 this 를 할당하는 경우와 Function.prototype 의 apply, call, bind 메서드를 사용하는 방법이 있습니다.

apply 와 call 은 this 를 bind 해주고 호출까지 해주는 것 까지는 동일하게 작동하나 apply 의 경우 배열을 인수로 받지만 call 의 경우 컴마로 구분된 리스트를 인수로 사용한다는 차이가 있습니다.

bind 는 this 를 바인딩만 해줄뿐 호출은 일어나지 않습니다. setTimeout 과 같은 경우에는 binding 한 이후에 바로 호출하지 않는 경우가 생기기 때문에 이러한 경우에는 call, apply 보다 bind 를 사용하는 것이 더 적절합니다.

## 메서드 호출

두 번째로는 메서드 호출입니다. 메서드 호출시에는 메서드 이름 앞의 마침표 연산자 앞에 기술한 객체가 비인딩 됩니다. 주의해야 할 것은 메서드 내부의 this 는 메서드를 소유한 객체가 아닌 메서드를 호출한 객체에 바인딩 된다는 점입니다.

Person 객체가 있고 이곳에 name 이 lee, 메서드로 name 을 return 하는 getName 메서드가 있다고 생각해보겠습니다. 이 getName 메서드는 person 객체에 포함된 것이 아닌 독립적으로 존재하는 별도의 객체입니다. getName 프로퍼티가 함수 객체를 가리키고 있을 뿐입니다.

즉, 메서드 내부의 this 는 프로퍼티로 메서드를 가리키고 있는 객체와는 관계가 없습니다. this 에 바인딩될 객체는 호출 시점에 결정되게 됩니다.

## 생성자 함수

마지막으로 생성자 함수 호출입니다. 생성자 함수 내부의 this 에는 생성자 함수가 미래에 생설할 인스턴스가 바인딩됩니다.

생성자 함수는 인스턴스를 생성합니다. 이 경우에 암묵적으로 빈 객체가 생성되고 this 에 binding 되게 됩니다.

 하지만 new 연산자와 함께 생성자 함수를 호출하지 않는다면 생성자 함수가 아닌 일반 함수로 동작하게 되므로, this 는 전역 객체를 가리키게 됩니다. 

이렇게 this 는 정적이 아닌 함수 호출에 따라 동적으로 결정되게 됩니다. 

