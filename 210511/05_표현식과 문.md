# 05_표현식과 문
값이라는 용어를 막상 설명하려고 하면 난감한 경우를 겪었던 적이 있었다. 개념을 이해한다는 것은, **용어를 정확하게 이해하고 설명할 수 있다는 것** 이다. 만약 용어를 정확하게 설명하지 못하면 개념을 제대로 이해하지 못한 경우가 많다.

값을 비롯해서 앞으로 정리해 나갈 대부분의 용어는 JS 뿐만이 아닌 컴퓨터 공학 전반에서 사용하는 요어이다. 용어에 대한 정확한 이해는 개념 정립에 필수불가결한 요소이다. 개발자 간의 의사소통 뿐만 아니라 메뉴얼 같은 문서의 이해와 프로그래밍 학습에 중요한 역할을 한다. 
## 1. 값
- 값은 **식이 평가되어 생성된 결과** 를 의미한다. 평가는 **식을 해석해서 값을 생성하거나 값을 참조하는 것** 을 의미한다. 
    - 그렇다면 단순히 변수에 저장하는 것은 **값이 저장된다** 라고 할 수 있을까??? **평가되어 생성된다** 에 어긋나지 않을까?? -> 표현식 부분에서 궁금증을 해결해줬다. 값을 할당하는 것은 결국 JS 엔진에서 할당한 값이 평가되어 생성되기 때문에 표현식으로 본다.
- 모든 값은 데아터 타입을 가진다. 메모리에 2진수, bit 의 나열로 저장된다. 메모리에 저장된 값들을 데이터 타입에 따라 다르게 해석이 가능하다. -> 숫자로 해석하느냐, 문자로 해석하느냐에 따라 0100 0001 이라는 값이 65가 될수도, 'A' 가 될 수도 있다.
- 변수는 **하나의 값을 저장하기 위해 확보한 메모리 공간** 또는 **메모리 공간을 식별하기 위해 붙인 이름(식별자)** 이다. 즉, 변수에 할당되는 것은 값이라고 할 수 있다.

## 2. 리터럴
- 리터럴은 **사람이 이해할 수 있는 문자** 또는 **약속된 기호를 사용해 값을 생성하는 표기 방식** 을 얘기한다. 리터럴은 사람이 이해할 수 있는 문자나 미리 약속된 기호로 표기한다. JS 엔진은 코드가 실행되는 시점인 런타임에 리터럴 평가후 값을 생성한다. -> 리터럴은 **값을 생성하기 위해 미리 약속한 표기방법이다.**

## 3. 표현식
- 표현식은 **값으로 평가될 수 있는 문**을 의미한다. 즉, 표현식이 평가되면 **새로운 값을 생성하거나 기존 값을 참조** 한다.
```javascript
var score = 100; // 100은 리터럴이지만 JS 엔진에 의해 평가된 후 값이 생성되기 때문에 리터럴은 그 자체로 표현식으로 본다.

var score = 50 + 50; // 리터럴과 연산자로 이루어져 있지만 50 + 50 으로 평가되어 숫자 값 100을 생성하기 때문에 표현식으로 본다.

score; // -> 100 변수 식별자 참조시에 변수 값 평가된다. 식별자 참조는 값을 생성하지 않지만 값으로 평가되므로 표현식이다.
```
- 표현식은 리터럴, 식별자, 연산자, 함수 호출 등의 조합으로 이루어진다. **값으로 평가되는 문은 모두 표현식**이다.
- 표현식과 표현식이 평가된 값은 동치를 이룬다. 예를 들어 수학 수식 4 + 5 = 9 에서 4 + 5 는 9 와 같다고 볼 수 있다. JS 에서 4 + 5 는 평가되어 값 9 를 생성하기 때문에 동치이다. 즉, 표현식은 값처럼 사용이 가능하다. -> 값이 위치할 수 있는 자리는 표현식도 위치할 수 있다. -> 표현식은 **다른 표현식의 일부가 될 수 있다.**

## 4. 문
- JS 를 설명할 때 **문** 과 **표현식** 이라는 용어가 자주 등장한다. 이들을 구별하고 해석이 가능하다면 JS 엔진의 입장에서 코드를 읽고 실행 결과 예측에 큰 도움이 될 수 있다. -> 버그를 줄이고 코드 품질을 높일 수 있어 확실히 이해할 필요가 있다.

- 문은 **프로그램을 구성하는 기본 단위**이자 **최소 실행 단위** 이다. 프로그램은 문의 집합으로 이루어져 있고 문을 순서에 맞게 작성하고 나열하는 것이 프로그래밍이다.

- 문은 여러 토큰으로 구성된다. 토큰은 **문법적인 의미를 가지지만 문법적으로 더 이상 나누지 못 하는 코드의 기본 요소** 를 의미한다. 
```javascript
// const, minus, =, 4, -, 3, ; 이 전부 토큰!
const minus = 4 - 3;
```
- 문은 **명령문**이라고도 부른다. -> 문은 **컴퓨터에 내리는 명령** 이다. 문이 실행되면 명령이 실행되고 무슨 일이 일어나게 된다.

- 문은 **선언문**, **조건문**, **반복문** 등으로 구분할 수 있다. 변수 선언문은 실행시 변수가 선언되고, 할당문은 값이 할당된다. 조건문은 지정한 조건에 따라 코드 블럭이 결정되어 실행되고 반복문은 특정 코드 블럭이 반복된다.

## 5. 세미콜론과 세미콜론 자동 삽입 기능
- 세미콜론(;)은 **문의 종료** 를 나타낸다. JS 엔진은 세미콜론을 통해 문의 종료 위치를 파악하고 순차적으로 하나씩 문을 실행시킨다. 따라서 문의 끝은 세미콜론이어야 한다. 단, 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 언제나 문을 종료를 의미하는 **자체 종결성**을 가지기 때문이다.

- 세미콜론은 옵션이다. 즉, 생략이 가능하다. JS 엔진은 소스코드 해석시 문의 끝을 예상해 세미콜론을 자동으로 붙여주는 **세미콜론 자동 삽입 기능** 이 암묵적 수행된다. 
- 하지만 자동 삽입 기능과 개발자의 예측이 일치하지 못하는 경우가 있다. **세미콜론을 반드시 붙여야 한다는 주장** 이 다수를 차지하지만 붙이지 말아야 한다는 주장도 설득력이 있다. ESLint 와 같은 정적 분석 도구는 **세미콜론 사용을 기본** 으로 설정하고 ECMAScript 기술 위원회도 **세미콜론 사용을 권장** 하는 분위기이므로 앞으로 정리시에 세미콜론을 붙이도록 한다.

## 6. 표현식인 문과 표현식이 아닌 문
- 표현식은 문의 일부이거나 그 자체로 문이 될 수 있다. 하지만 표현식과 문은 비슷해서 구별하기 어렵다. 의외로 표현식과 문을 구별하는 방법은 간단하다.
- 문에는 **표현식인 문** 과 **표현식이 아닌 문** 이 있다. 표현식인 문은 **값으로 평가될 수 있는 문** 이고 표현식이 아닌 문은 **값으로 평가될 수 없는 문** 이다. 예를 들어 변수 선언문은 값으로 평가 될 수 없다. 즉 표현식이 아닌 문이다. 하지만 할당문은 값으로 평가가 가능하기 때문에 표현식인 문이다.
- 표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단한 방법은 **변수에 할당** 해보는 것이다. 표현식인 문은 값이기 때문에 변수 할당이 가능하다. 하지만 표현식이 아닌 문은 값으로 평가 될 수 없어 변수 할당시 에러가 발생한다.
```javascript
var x; // 문
x = 100; // 표현식이자 문

var foo = var x // 표현식이 아닌 문이기 때문에 값처럼 사용이 불가능하다.
var foo = x = 100; // 표현식인 문은 값처럼 사용이 가능하다.
```

- 할당문을 값처럼 변수에 할당이 가능하다. 표현식인 문은 할당문은 할당한 값으로 평가 되고 x 변수에 100이 할당되고 foo 에도 100이 할당된다.
